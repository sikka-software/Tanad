---
description: 
globs: 
alwaysApply: true
---
# Module Service Pattern Guide

This document outlines the standardized pattern for implementing services in module components.

## Service Structure

Each module's `service.ts` file should implement these standard methods:

```typescript
// <module-name>.service.ts
import { supabase } from '@/lib/supabase';
import type { ModuleName, ModuleNameCreateData, ModuleNameUpdateData } from './module-name.type';

export class ModuleNameService {
  private static readonly TABLE_NAME = 'module_names';

  // List all records
  static async list(): Promise<ModuleName[]> {
    const { data, error } = await supabase
      .from(this.TABLE_NAME)
      .select('*')
      .order('created_at', { ascending: false });

    if (error) throw error;
    return data;
  }

  // Get single record
  static async get(id: string): Promise<ModuleName> {
    const { data, error } = await supabase
      .from(this.TABLE_NAME)
      .select('*')
      .eq('id', id)
      .single();

    if (error) throw error;
    return data;
  }

  // Create record
  static async create(data: ModuleNameCreateData): Promise<ModuleName> {
    const { data: created, error } = await supabase
      .from(this.TABLE_NAME)
      .insert(data)
      .select()
      .single();

    if (error) throw error;
    return created;
  }

  // Update record
  static async update(id: string, data: ModuleNameUpdateData): Promise<ModuleName> {
    const { data: updated, error } = await supabase
      .from(this.TABLE_NAME)
      .update(data)
      .eq('id', id)
      .select()
      .single();

    if (error) throw error;
    return updated;
  }

  // Delete record
  static async delete(id: string): Promise<void> {
    const { error } = await supabase
      .from(this.TABLE_NAME)
      .delete()
      .eq('id', id);

    if (error) throw error;
  }

  // Bulk delete records
  static async bulkDelete(ids: string[]): Promise<void> {
    const { error } = await supabase
      .from(this.TABLE_NAME)
      .delete()
      .in('id', ids);

    if (error) throw error;
  }

  // Duplicate record
  static async duplicate(id: string): Promise<ModuleName> {
    // 1. Get the original record
    const original = await this.get(id);

    // 2. Remove unique fields and create new record
    const { id: _, created_at: __, ...duplicateData } = original;
    
    // 3. Create the duplicate
    return this.create(duplicateData as ModuleNameCreateData);
  }
}
```

## Method Naming Conventions

1. List Records: `list()`
2. Get Single Record: `get(id)`
3. Create Record: `create(data)`
4. Update Record: `update(id, data)`
5. Delete Record: `delete(id)`
6. Bulk Delete: `bulkDelete(ids)`
7. Duplicate: `duplicate(id)`

## Error Handling Pattern

Implement consistent error handling:

```typescript
static async operation(): Promise<Result> {
  try {
    const { data, error } = await supabase
      // ... operation
    
    if (error) throw error;
    return data;
  } catch (error) {
    console.error('ModuleNameService.operation error:', error);
    throw error;
  }
}
```

## Query Building Patterns

Follow consistent query building patterns:

```typescript
// Basic select
.from(TABLE_NAME).select('*')

// Filtered select
.from(TABLE_NAME)
.select('*')
.eq('field', value)

// Ordered select
.from(TABLE_NAME)
.select('*')
.order('created_at', { ascending: false })

// Pagination
.from(TABLE_NAME)
.select('*')
.range(start, end)

// Relationships
.from(TABLE_NAME)
.select(`
  *,
  related_table(*)
`)
```

## Example Implementation

For reference implementation, see:
- Companies service: [src/modules/company/company.service.ts](mdc:src/modules/company/company.service.ts)
- Branches service: [src/modules/branch/branch.service.ts](mdc:src/modules/branch/branch.service.ts)

## Best Practices

1. Use TypeScript for type safety
2. Implement proper error handling
3. Use consistent method naming
4. Document complex queries
5. Keep methods focused and single-purpose
6. Use table constants
7. Handle relationships properly
8. Validate input data
9. Use proper return types
10. Maintain consistent error messages

## Security Considerations

1. Always use parameterized queries
2. Never expose internal errors to clients
3. Validate input data
4. Use RLS policies
5. Handle sensitive data appropriately
6. Implement proper access control
7. Use appropriate error codes

